==========================================
SLURM_CLUSTER_NAME = paramutkarsh
SLURM_ARRAY_JOB_ID = 
SLURM_ARRAY_TASK_ID = 
SLURM_ARRAY_TASK_COUNT = 
SLURM_ARRAY_TASK_MAX = 
SLURM_ARRAY_TASK_MIN = 
SLURM_JOB_ACCOUNT = cdac
SLURM_JOB_ID = 40223
SLURM_JOB_NAME = prof_serial
SLURM_JOB_NODELIST = cn082
SLURM_JOB_USER = chuk355
SLURM_JOB_UID = 23411
SLURM_JOB_PARTITION = cpu
SLURM_TASK_PID = 27977
SLURM_SUBMIT_DIR = /home/chuk355/HPC-NBody
SLURM_CPUS_ON_NODE = 48
SLURM_NTASKS = 1
SLURM_TASK_PID = 27977
==========================================
============================================
Profiling Standard Serial Implementation
Particles (N) : 10000
Steps         : 1000
Output Dir    : vtune_reports/serial_N10000_ID40223
Date          : Thu Dec 25 14:21:21 UTC 2025
============================================


--- N-Body Serial Simulation ---
Bodies: 10000 | Steps: 1000
Mode:   BENCHMARK (No File Output)

--- Results ---
Time:   496.116 s
Perf:   4.03132 GFLOPs
Elapsed Time: 503.504s
    CPU Time: 484.640s
        Effective Time: 484.640s
            Idle: 2.992s
            Poor: 481.648s
            Ok: 0s
            Ideal: 0s
            Over: 0s
        Spin Time: 0s
        Overhead Time: 0s
    Total Thread Count: 1
    Paused Time: 0s

Top Hotspots
Function                                             Module          CPU Time
---------------------------------------------------  --------------  --------
update_physics                                       nbody_serial    484.550s
__memset_sse2                                        libc.so.6         0.040s
std::vector<Body, std::allocator<Body>>::operator[]  nbody_serial      0.020s
operator new                                         libstdc++.so.6    0.010s
operator delete                                      libstdc++.so.6    0.010s
std::ostream::operator<<                             nbody_serial      0.010s
Effective CPU Utilization: 2.0%
 | The metric value is low, which may signal a poor logical CPU cores
 | utilization caused by load imbalance, threading runtime overhead, contended
 | synchronization, or thread/process underutilization. Explore sub-metrics to
 | estimate the efficiency of MPI and OpenMP parallelism or run the Locks and
 | Waits analysis to identify parallel bottlenecks for other parallel runtimes.
 |
    Average Effective CPU Utilization: 0.956 out of 48
Collection and Platform Info
    Application Command Line: ./bin/nbody_serial "10000" "1000" "bench" 
    Operating System: 3.10.0-1160.el7.x86_64 \S Kernel \r on an \m 
    Computer Name: cn082
    Result Size: 12.7 MB 
    Collection start time: 14:43:57 25/12/2025 UTC
    Collection stop time: 14:52:21 25/12/2025 UTC
    Collector Type: Driverless Perf per-process counting,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Cascadelake
        Frequency: 2.893 GHz 
        Logical CPU Count: 48
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.
Profiling finished. Result saved to: vtune_reports/serial_N10000_ID40223
